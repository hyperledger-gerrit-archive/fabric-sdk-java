/*
 *  Copyright 2016 DTCC, Fujitsu Australia Software Technology - All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * 	  http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.hyperledger.fabric.sdk.transaction;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hyperledger.fabric.protos.peer.Chaincode;
import org.hyperledger.fabric.protos.peer.FabricProposal;
import org.hyperledger.fabric.sdk.exception.DeploymentException;
import org.hyperledger.fabric.sdk.helper.SDKUtil;

import com.google.common.io.Files;
import com.google.protobuf.ByteString;
import com.google.protobuf.Timestamp;

import io.netty.util.internal.StringUtil;


public class DeploymentProposalBuilder extends  ProposalBuilder{

    private static Log logger = LogFactory.getLog(DeploymentProposalBuilder.class);

    //TODO: is this really a static chain name? or can be replaced with the current chain.getName()?
    private String LCCC_CHAIN_NAME = "lccc";

    private boolean devMode = false;

    private DeploymentProposalBuilder() {
        super();
    }

    public static DeploymentProposalBuilder newBuilder() {
        return new DeploymentProposalBuilder();
    }

    public DeploymentProposalBuilder devMode(boolean devMode) {
    	this.devMode = devMode;
    	return this;
    }

    @Override
    public FabricProposal.Proposal build() {
    	try {
    		createDeploymentProposal();
    		return super.build();
    	} catch(IOException ioexp) {
	    throw new DeploymentException("Failed to build deployment proposal", ioexp);
    	}
    }

    public void createDeploymentProposal() throws IOException {
            if(devMode){
                createDevModeTransaction();
            }else {
                createNetModeTransaction();
            }
    }

    private void createNetModeTransaction() throws IOException {
        logger.debug("newNetModeTransaction");

        if (getChaincodeID() == null || StringUtil.isNullOrEmpty(getChaincodeID().getPath())) {
	    throw new IllegalArgumentException("[NetMode] Missing chaincodePath in DeployRequest");
        }

        String rootDir = "";
        String chaincodeDir = "";

        if (getChaincodeType() == Chaincode.ChaincodeSpec.Type.GOLANG) {
            // Determine the user's $GOPATH
            String goPath = System.getenv("GOPATH");
            logger.info(String.format("Using GOPATH :%s", goPath));
	    if (StringUtil.isNullOrEmpty(goPath)) {
		throw new IllegalArgumentException("[NetMode] Missing GOPATH environment variable");
	    }

            logger.debug("$GOPATH: " + goPath);

            // Compose the path to the chaincode project directory
            rootDir = SDKUtil.combinePaths(goPath,  "src");
            chaincodeDir = getChaincodeID().getPath();
        } else {
            // Compose the path to the chaincode project directory
            File ccFile = new File(getChaincodeID().getPath());
            rootDir = ccFile.getParent();
            chaincodeDir = ccFile.getName();
        }

        String projDir = SDKUtil.combinePaths(rootDir, chaincodeDir);
        logger.debug("projDir: " + projDir);

        String dockerFileContents =  getDockerFileContents(getChaincodeType());

        String ccName = getChaincodeID().getName();
        if (StringUtil.isNullOrEmpty(ccName)) {
        	ccName = SDKUtil.generateUUID(); // autogenerated cc name
        }

        dockerFileContents = String.format(dockerFileContents, ccName);

        // Create a Docker file with dockerFileContents
        String dockerFilePath = SDKUtil.combinePaths(projDir, "Dockerfile");
        Files.write(dockerFileContents.getBytes(), new java.io.File(dockerFilePath));

        logger.debug(String.format("Created Dockerfile at [%s]", dockerFilePath));

        // Create the .tar.gz file of the chaincode package
        //TODO: How does it work if multiple threads/applications are trying to deploy different chaincodes?
        String targzFilePath = SDKUtil.combinePaths(System.getProperty("java.io.tmpdir"), "deployment-package.tar.gz");
        // Create the compressed archive
        SDKUtil.generateTarGz(projDir, targzFilePath);
        byte[] data = SDKUtil.readFile(new File(targzFilePath));

        // Clean up temporary files
        SDKUtil.deleteFileOrDirectory(new File(targzFilePath));
        SDKUtil.deleteFileOrDirectory(new File(dockerFilePath));

		Chaincode.ChaincodeDeploymentSpec depspec = createDeploymentSpec(data);

        List<ByteString> argList = new ArrayList<>();
        argList.add(ByteString.copyFromUtf8("deploy"));
        argList.add(ByteString.copyFromUtf8("default"));
        argList.add(depspec.toByteString());

        Chaincode.ChaincodeID lcccID = Chaincode.ChaincodeID.newBuilder().setName(LCCC_CHAIN_NAME).build();
        args(argList);
        chaincodeID(lcccID);
    }


    private void createDevModeTransaction() {
        logger.debug("newDevModeTransaction");

        Chaincode.ChaincodeDeploymentSpec depspec = createDeploymentSpec(null);

        Chaincode.ChaincodeID lcccID = Chaincode.ChaincodeID.newBuilder().setName(LCCC_CHAIN_NAME).build();

        List<ByteString> argList = new ArrayList<>();
        argList.add(ByteString.copyFromUtf8("deploy"));
        argList.add(ByteString.copyFromUtf8("default"));
        argList.add(depspec.toByteString());

        args(argList);
        chaincodeID(lcccID);


    }


	private Chaincode.ChaincodeDeploymentSpec createDeploymentSpec(byte[] codePackage) {
        logger.trace("Creating deployment Specification.");

        // build chaincodeInput
		List<ByteString> argList = getArgList();

        Chaincode.ChaincodeInput chaincodeInput = Chaincode.ChaincodeInput.newBuilder().addAllArgs(argList).build();

		// Construct the ChaincodeSpec
		Chaincode.ChaincodeSpec chaincodeSpec = Chaincode.ChaincodeSpec.newBuilder().setType(getChaincodeType())
		        .setChaincodeID(getChaincodeID()).setCtorMsg(chaincodeInput)
		        .setConfidentialityLevel(Chaincode.ConfidentialityLevel.PUBLIC).build();


        Chaincode.ChaincodeDeploymentSpec.Builder chaincodeDeploymentSpecBuilder = Chaincode.ChaincodeDeploymentSpec
                .newBuilder().setChaincodeSpec(chaincodeSpec).setEffectiveDate(Timestamp.getDefaultInstance())
                .setExecEnv(Chaincode.ChaincodeDeploymentSpec.ExecutionEnvironment.DOCKER);

        if (codePackage != null) {
        	chaincodeDeploymentSpecBuilder.setCodePackage(ByteString.copyFrom(codePackage));
        }

        return chaincodeDeploymentSpecBuilder.build();

    }




    private String getDockerFileContents(Chaincode.ChaincodeSpec.Type lang) throws IOException {
        if (lang == Chaincode.ChaincodeSpec.Type.GOLANG) {
            return new String(SDKUtil.readFileFromClasspath("Go.Docker"));
        } else if (lang == Chaincode.ChaincodeSpec.Type.JAVA) {
            return new String(SDKUtil.readFileFromClasspath("Java.Docker"));
        }

        throw new UnsupportedOperationException(String.format("Chaincode language '%s' is not supported", lang));
    }
}
