/*
 *
 *  Copyright IBM Corp. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package org.hyperledger.fabric.sdk.identity;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import com.google.protobuf.InvalidProtocolBufferException;
import org.apache.milagro.amcl.FP256BN.BIG;
import org.apache.milagro.amcl.FP256BN.ECP;
import org.hyperledger.fabric.protos.idemix.Idemix;
import org.hyperledger.fabric.protos.msp.Identities;
import org.hyperledger.fabric.protos.msp.MspConfig.IdemixMSPSignerConfig;
import org.hyperledger.fabric.sdk.exception.CryptoException;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.idemix.IdemixCredential;
import org.hyperledger.fabric.sdk.idemix.IdemixIssuerPublicKey;
import org.hyperledger.fabric.sdk.idemix.IdemixPseudonym;
import org.hyperledger.fabric.sdk.idemix.IdemixSignature;
import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

/**
 * Tests for IdemixIdentity and IdemixSigningIdentity
 */
public class IdemixIdentitiesTest {

    // Test resources with crypto material generated by the idemixgen tool (in go)
    private static final String TEST_PATH = "src/test/resources/idemix/";
    private static final String USER_PATH = "/user/";
    private static final String VERIFIER_PATH = "/msp/";
    private static final String MSP1Broken = "MSP1Broken";
    private static final String MSP1OU1 = "MSP1OU1";
    private static final String MSP1OU12ATR = "MSP1OU12ATR";
    private static final String MSP1OU1Admin = "MSP1OU1Admin";
    private static final String MSP1OU2 = "MSP1OU2";
    private static final String MSP1Verifier = "MSP1Verifier";
    private static final String MSP2OU1 = "MSP2OU1";
    private static final String SIGNER_CONFIG = "SignerConfig";
    private static final String IPK_CONFIG = "IssuerPublicKey";


    private static IdemixCredential cred = null;
    private static IdemixIssuerPublicKey ipk = null;
    private static BIG sk = null;
    private static IdemixPseudonym nym = null;
    private static ECP nymPublic = null;
    private static IdemixSignature proof = null;
    private static IdemixSigningIdentity signingIdentity = null;

    private static byte[] ou = null;
    private static byte[] role = null;

    private static byte[] message = {1, 2, 3, 4};
    private static byte[] sigTest = {1, 2, 3, 4};


    // Setup using a happy path
    @BeforeClass
    public static void setup() {

        // Parse crypto material from files
        IdemixMSPSignerConfig signerConfig = null;
        try {
            signerConfig = readIdemixMSPConfig(TEST_PATH + MSP1OU1 + USER_PATH, SIGNER_CONFIG);
        } catch (IOException e1) {
            fail("Unexpected IOException" + e1.getMessage());
        }
        assertNotNull(signerConfig);

        Idemix.IssuerPublicKey ipkProto = null;
        try {
            ipkProto = readIdemixIssuerPublicKey(TEST_PATH + MSP1OU1 + VERIFIER_PATH, IPK_CONFIG);
        } catch (IOException e1) {
            fail("Unexpected IOException" + e1.getMessage());
        }

        ipk = new IdemixIssuerPublicKey(ipkProto);
        assertTrue(ipk.check());

        sk = BIG.fromBytes(signerConfig.getSk().toByteArray());

        Idemix.Credential credProto = null;
        try {
            credProto = Idemix.Credential.parseFrom(signerConfig.getCred());
        } catch (InvalidProtocolBufferException e) {
            fail("Could not parse a credential");
        }

        assertNotNull(credProto);

        cred = new IdemixCredential(credProto);

        try {
            signingIdentity = new IdemixSigningIdentity(ipk, MSP1OU1, sk, cred);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Could not create Idemix Signing Identity" + e.getMessage());
        }

        assertNotNull(signingIdentity);

        nym = signingIdentity.getNym();

        nymPublic = nym.getNym();

        ou = cred.getAttrs()[0];
        role = cred.getAttrs()[1];

        proof = signingIdentity.getProof();

    }

    // Test creating a signing identity with MSP1Verifier (should fail)
    @Test (expected = IOException.class)
    public void testIdemixSigningIdentityVerifier() throws IOException {
        try {
            createIdemixSigningIdentity(MSP1Verifier);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Unexpected Exception" + e.getMessage());
        }

    }

    // Test creating a signing identity with MSP1Broken (should fail)
    @Test (expected = IOException.class)
    public void testIdemixSigningIdentityBroken() throws IOException {
        try {
            createIdemixSigningIdentity(MSP1Broken);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Unexpected Exception" + e.getMessage());
        }

    }

    // Test creating a signing identity with wrong number of attibutes (should fail)
    @Test (expected = CryptoException.class)
    public void testIdemixSigningIdentityWrongAttributes() throws CryptoException {
        try {
            createIdemixSigningIdentity(MSP1OU12ATR);
        } catch (IOException | InvalidArgumentException e) {
            fail("Unexpected Exception" + e.getMessage());
        }

    }

    // Test creating a signer config
    @Test
    public void testIdemixMSPSignerConfigSuccess() {

        IdemixMSPSignerConfig signerConfig = null;
        try {
            signerConfig = readIdemixMSPConfig(TEST_PATH + MSP1OU1 + USER_PATH, SIGNER_CONFIG);
        } catch (InvalidProtocolBufferException e) {
            fail("Unexpected IPBException" + e.getMessage());
        } catch (IOException e) {
            fail("Unexpected IOException" + e.getMessage());
        }

        assertNotNull(signerConfig);

    }

    // Test creating a signing identity from null input

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNullPk() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(null, MSP1OU1, sk, cred);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception");
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNullMsp() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, null, sk, cred);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputEmptymsp() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, "", sk, cred);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNullSk() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, MSP1OU1, null, cred);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNullCred() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, MSP1OU1, sk, null);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNymProofNullNym() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, MSP1OU1, sk, cred, null, proof);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixSigningIdentityInputNymProofNullProof() throws InvalidArgumentException {
        try {
            new IdemixSigningIdentity(ipk, MSP1OU1, sk, cred, nym, null);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test
    public void testIdemixSigningIdentityInputNymProof() {
        try {
            new IdemixSigningIdentity(ipk, MSP1OU1, sk, cred, nym, proof);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Unexpected exception" + e.getMessage());
        }
    }


    // Test Signing and Verification with Signing Identity
    @Test (expected = InvalidArgumentException.class)
    public void testSigningNullMsg() throws InvalidArgumentException {
        try {
            testSigning(signingIdentity, message, null, true);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testSigningNullSig() throws InvalidArgumentException {
        try {
            testSigning(signingIdentity, null, sigTest, true);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testSigningNullMsgSig() throws InvalidArgumentException {
        try {
            testSigning(signingIdentity, null, null, true);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }
    }

    @Test
    public void testSigningSuccess() throws InvalidArgumentException {
        boolean b = false;
        try {
            b = testSigning(signingIdentity, message, null, false);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception" + e.getMessage());
        }

        assertTrue(b);
    }


    @Test
    public void testSerializingAndDeserializingIdentity() {
        Identities.SerializedIdentity proto = signingIdentity.createSerializedIdentity();
        assertNotNull(proto);

        Identities.SerializedIdemixIdentity idemixProto = null;
        try {
            idemixProto = Identities.SerializedIdemixIdentity.parseFrom(proto.getIdBytes());
        } catch (InvalidProtocolBufferException e) {
            fail("Could not parse Idemix Serialized Identity" + e.getMessage());
        }
        if (idemixProto != null) {
            new ECP(BIG.fromBytes(idemixProto.getNymX().toByteArray()), BIG.fromBytes(idemixProto.getNymY().toByteArray()));
            idemixProto.getOU().toByteArray();
            idemixProto.getRole().toByteArray();
            try {
                new IdemixSignature(Idemix.Signature.parseFrom(idemixProto.getProof().toByteArray()));
            } catch (InvalidProtocolBufferException e) {
                fail("Cannot deserialize proof" + e.getMessage());
            }
        }

        try {
            new IdemixIdentity(proto);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Cannot create Idemix Identity from Proto" + e.getMessage());
        }

    }

    // Test creating IdemixIdentity

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNull() throws InvalidArgumentException {
        try {
            new IdemixIdentity(null);
        } catch (CryptoException e) {
            fail("Unexpected Crypto exception " + e.getMessage());
        }
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNullMsp() throws InvalidArgumentException {
        new IdemixIdentity(null, nymPublic, ou, role, proof);
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNullNym() throws InvalidArgumentException {
        new IdemixIdentity(MSP1OU1, null, ou, role, proof);
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNullOu() throws InvalidArgumentException {
        new IdemixIdentity(MSP1OU1, nymPublic, null, role, proof);
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNullRole() throws InvalidArgumentException {
        new IdemixIdentity(MSP1OU1, nymPublic, ou, null, proof);
    }

    @Test (expected = InvalidArgumentException.class)
    public void testIdemixIdentityInputNullProof() throws InvalidArgumentException {
        new IdemixIdentity(MSP1OU1, nymPublic, ou, role, null);
    }

    @Test
    public void testIdemixIdentity() {
        try {
            new IdemixIdentity(MSP1OU1, nymPublic, ou, role, proof);
        } catch (InvalidArgumentException e) {
            fail("Unexpected Invalid Argument exception" + e.getMessage());
        }
    }


    // Test creating different signing identities
    @Test
    public void testSigningIdentityMSP1OU1Admin() {
        assertTrue(testCreatingSigningIdentityAndSign(MSP1OU1Admin));
    }

    @Test
    public void testSigningIdentityMSP1OU2() {
        assertTrue(testCreatingSigningIdentityAndSign(MSP1OU2));
    }

    @Test
    public void testSigningIdentityMSP2OU1() {
        assertTrue(testCreatingSigningIdentityAndSign(MSP2OU1));
    }

    // Helper functions

    /**
     * Helper function to create a Signing Identity and sign with it
     * @param mspId
     * @return
     */
    public boolean testCreatingSigningIdentityAndSign(String mspId) {

        boolean b = false;

        IdemixSigningIdentity signingIdentityTest = null;
        try {
            signingIdentityTest = createIdemixSigningIdentity(mspId);
        } catch (CryptoException | InvalidArgumentException | IOException e) {
            fail("Unexpected exception: " + e.getMessage());
        }

        assertNotNull(signingIdentityTest);

        // Test signing using this identity
        try {
            b = testSigning(signingIdentityTest, message, null, false);
        } catch (CryptoException | InvalidArgumentException e) {
            fail("Unexpected exception: " + e.getMessage());
        }

        return b;
    }



    /**
     * Helper function for testing signing
     * @param signingIdentity
     * @return
     * @throws InvalidArgumentException
     */
    public boolean testSigning(IdemixSigningIdentity signIdentity, byte[] msg, byte[] sigInput, boolean useInputSig) throws CryptoException, InvalidArgumentException {

        byte[] sig = signIdentity.sign(msg);

        if (useInputSig) {
            return signIdentity.verifySignature(msg, sigInput);
        } else {
            return signIdentity.verifySignature(msg, sig);
        }
    }

    /**
     * Helper function to create IdemixSigningIdentity from a file generated by idemixgen go tool
     *
     * @param mspId
     * @return IdemixSigningIdentity object
     * @throws IOException
     * @throws InvalidProtocolBufferException
     */
    public IdemixSigningIdentity createIdemixSigningIdentity(String mspId) throws CryptoException, InvalidArgumentException, InvalidProtocolBufferException, IOException {
        IdemixMSPSignerConfig signerConfig = null;
        signerConfig = readIdemixMSPConfig(TEST_PATH + mspId + USER_PATH, SIGNER_CONFIG);
        assertNotNull(signerConfig);

        Idemix.IssuerPublicKey ipkProto = readIdemixIssuerPublicKey(TEST_PATH + mspId + VERIFIER_PATH, IPK_CONFIG);
        IdemixIssuerPublicKey ipk = new IdemixIssuerPublicKey(ipkProto);
        assertTrue(ipk.check());

        BIG sk = BIG.fromBytes(signerConfig.getSk().toByteArray());

        Idemix.Credential credProto = Idemix.Credential.parseFrom(signerConfig.getCred());

        assertNotNull(credProto);

        IdemixCredential cred = new IdemixCredential(credProto);

        return new IdemixSigningIdentity(ipk, mspId, sk, cred);
    }

    /**
     * Helper function: parse Idemix MSP Signer config (is part of the MSPConfig proto) from path
     *
     * @param configPath
     * @param id
     * @return IdemixMSPSignerConfig proto
     */
    public static IdemixMSPSignerConfig readIdemixMSPConfig(String configPath, String id) throws IOException {

        Path path = Paths.get(configPath + id);
        byte[] data = Files.readAllBytes(path);
        IdemixMSPSignerConfig signerConfig = IdemixMSPSignerConfig.parseFrom(data);
        return signerConfig;
    }

    /**
     * Parse Idemix issuer public key from the config file
     *
     * @param configPath
     * @param id
     * @return Idemix IssuerPublicKey proto
     */
    public static Idemix.IssuerPublicKey readIdemixIssuerPublicKey(String configPath, String id) throws IOException {

        Path path = Paths.get(configPath + id);
        byte[] data =  Files.readAllBytes(path);
        Idemix.IssuerPublicKey ipk = Idemix.IssuerPublicKey.parseFrom(data);
        return ipk;
    }
}
